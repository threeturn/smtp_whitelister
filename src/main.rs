use trust_dns_resolver::config::*;
use trust_dns_resolver::Resolver;
use regex::Regex;
use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

/// Function to retrieve all IPs from a list of SPF domains
fn get_ips_from_spf(domains: &[String]) -> Vec<String> {
    let resolver = Resolver::new(ResolverConfig::default(), ResolverOpts::default())
        .expect("Failed to create DNS resolver");

    let include_re = Regex::new(r"include:([^ ]+)").unwrap();
    let ip_re = Regex::new(r"(ip4|ip6):([a-fA-F0-9.:/]+)").unwrap();

    let mut whitelist_ips = Vec::new();

    for domain in domains {
        // Retrieve TXT records for the domain
        if let Ok(response) = resolver.txt_lookup(domain) {
            for record in response.iter() {
                let txt_data: String = record.iter()
                    .map(|bytes| String::from_utf8_lossy(bytes).to_string())
                    .collect();

                // Follow include entries in the SPF record
                for include in include_re.captures_iter(&txt_data) {
                    let subdomain = &include[1];
                    if let Ok(sub_response) = resolver.txt_lookup(subdomain) {
                        for sub_record in sub_response.iter() {
                            let sub_txt_data: String = sub_record.iter()
                                .map(|bytes| String::from_utf8_lossy(bytes).to_string())
                                .collect();

                            // Extract IPs from the subdomain's TXT data
                            for ip_match in ip_re.captures_iter(&sub_txt_data) {
                                let ip = &ip_match[2];
                                whitelist_ips.push(ip.to_string());
                            }
                        }
                    }
                }

                // Extract IPs directly from the main TXT record
                for ip_match in ip_re.captures_iter(&txt_data) {
                    let ip = &ip_match[2];
                    whitelist_ips.push(ip.to_string());
                }
            }
        } else {
            eprintln!("Failed to retrieve TXT records for domain: ->{}<-", domain);
        }
    }

    whitelist_ips
}

/// Function to load domains from a file, one domain per line
fn load_domains_from_file(filename: &str) -> io::Result<Vec<String>> {
    let path = Path::new(filename);
    let file = File::open(&path)?;
    let reader = io::BufReader::new(file);

    let mut domains = Vec::new();
    for line in reader.lines() {
        if let Ok(domain) = line {
            domains.push(domain.trim().to_string());
        }
    }
    dbg!(&domains);
    Ok(domains)
}

fn main() {
    // Load the list of domains from a file
    let filename = "domains.txt";
    let domains = load_domains_from_file(filename).expect("Failed to load domains from file");

    // Retrieve IPs for the loaded domains
    let ips = get_ips_from_spf(&domains);

    // Output IPs in a format suitable for Postfix
    println!("/SMTP IPs for Postfix Whitelist. Generated by smtp_whitelister.");
    for ip in ips {
        println!("{} OK", ip);
    }
}
